<!DOCTYPE html>
<html>

<head>
	<title>Sprite Editor</title>

	<style>
		button {
			width: 50px;
			height: 16px;
			background-color: #007BFF;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			font-size: 16px;
			margin: 4px !important;
			padding: 0px;
			line-height: 0px;
			display: block;
			text-align: center;
		}

		button:hover {
			background-color: #0056b3;
		}

		table {
			border-collapse: collapse;
			margin: 0px;
			padding: 0px;
			width: 60%;
			text-align: center;
		}

		canvas,
		h3,
		thead,
		th,
		tr,
		td {
			margin: 0px;
			padding: 0px;
			border: 2px solid #000;
		}

		tr.custom-height {
			height: 100%;
		}

		td {
			width: 50px !important;
			height: 50px !important;
			vertical-align: middle;
		}

		textarea {
			height: 30%;
		}
	</style>

</head>

<body>

	<table>
		<thead>
			<tr>
				<th colspan="3">Controls</th>
				<th>ToolboxAid.com (Enhancing Skills)</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td></td>
				<td>
					<button onclick="moveImageVertical(-100.0)">-100</button>
					<button onclick="moveImageVertical(-10.00)">-10.0</button>
					<button onclick="moveImageVertical(-1.000)">-1.00</button>
				</td>
				<td></td>
				<td rowspan="11"> <canvas id="spriteEditor"></canvas></td>
				<td rowspan="11">
					<h3>Pallet Color<p>(add '#00000000' for Transparent)</p></h3>
					<textarea id="palletID" name="pallet" rows="35" cols="35" style="height: 55%;">
// Pink Colors'						
'!':'#FFC0CB':'Pink'
'"':'#FFB6C1':'LightPink'
'#':'#FF69B4':'HotPink'
'$':'#FF1493':'DeepPink'
'%':'#DB7093':'PaleVioletRed'
'&':'#C71585':'MediumVioletRed'
// Red Colors
':':'#FFA07A':'LightSalmon'
';':'#FA8072':'Salmon'
'<':'#E9967A':'DarkSalmon'
'=':'#F08080':'LightCoral'
'>':'#CD5C5C':'IndianRed'
'?':'#DC143C':'Crimson'
'@':'#FF0000':'Red'
'A':'#B22222':'FireBrick'
'B':'#8B0000':'DarkRed'
// Orange Colors
'C':'#FFA500':'Orange'
'D':'#FF8C00':'DarkOrange'
'E':'#FF7F50':'Coral'
'F':'#FF6347':'Tomato'
'G':'#FF4500':'OrangeRed'
// Yellow Colors
'H':'#FFD700':'Gold'
'I':'#FFFF00':'Yellow'
'J':'#FFFFE0':'LightYellow'
'K':'#FFFACD':'LemonChiffon'
'L':'#FAFAD2':'LightGoldenRodYellow'
'M':'#FFEFD5':'PapayaWhip'
'N':'#FFE4B5':'Moccasin'
'O':'#FFDAB9':'PeachPuff'
'P':'#EEE8AA':'PaleGoldenRod'
'Q':'#F0E68C':'Khaki'
'R':'#BDB76B':'DarkKhaki'
// Green Colors
'S':'#ADFF2F':'GreenYellow'
'T':'#7FFF00':'Chartreuse'
'U':'#7CFC00':'LawnGreen'
'V':'#00FF00':'Lime'
'W':'#32CD32':'LimeGreen'
'X':'#98FB98':'PaleGreen'
'Y':'#90EE90':'LightGreen'
'Z':'#00FA9A':'MediumSpringGreen'
'[':'#00FF7F':'SpringGreen'
'\':'#3CB371':'MediumSeaGreen'
']':'#2E8B57':'SeaGreen'
'^':'#228B22':'ForestGreen'
'_':'#008000':'Green'
'`':'#006400':'DarkGreen'
'a':'#9ACD32':'YellowGreen'
'b':'#6B8E23':'OliveDrab'
'c':'#556B2F':'DarkOliveGreen'
'd':'#66CDAA':'MediumAquaMarine'
'e':'#8FBC8F':'DarkSeaGreen'
'f':'#20B2AA':'LightSeaGreen'
'g':'#008B8B':'DarkCyan'
'h':'#008080':'Teal'
// Cyan Colors
'i':'#00FFFF':'Aqua'
'j':'#00FFFF':'Cyan'
'k':'#E0FFFF':'LightCyan'
'l':'#AFEEEE':'PaleTurquoise'
'm':'#7FFFD4':'Aquamarine'
'n':'#40E0D0':'Turquoise'
'o':'#48D1CC':'MediumTurquoise'
'p':'#00CED1':'DarkTurquoise'
// Blue Colors
'q':'#5F9EA0':'CadetBlue'
'r':'#4682B4':'SteelBlue'
's':'#B0C4DE':'LightSteelBlue'
't':'#ADD8E6':'LightBlue'
'u':'#B0E0E6':'PowderBlue'
'v':'#87CEFA':'LightSkyBlue'
'w':'#87CEEB':'SkyBlue'
'x':'#6495ED':'CornflowerBlue'
'y':'#00BFFF':'DeepSkyBlue'
'z':'#1E90FF':'DodgerBlue'
'{':'#4169E1':'RoyalBlue'
'|':'#0000FF':'Blue'
'}':'#0000CD':'MediumBlue'
'~':'#00008B':'DarkBlue'
'¡':'#000080':'Navy'
'¢':'#191970':'MidnightBlue'
// Purple Colors
''':'#E6E6FA':'Lavender'
'(':'#D8BFD8':'Thistle'
')':'#DDA0DD':'Plum'
'*':'#DA70D6':'Orchid'
'+':'#EE82EE':'Violet'
',':'#FF00FF':'Fuchsia'
'-':'#FF00FF':'Magenta'
'.':'#BA55D3':'MediumOrchid'
'/':'#9932CC':'DarkOrchid'
'0':'#9400D3':'DarkViolet'
'1':'#8A2BE2':'BlueViolet'
'2':'#8B008B':'DarkMagenta'
'3':'#800080':'Purple'
'4':'#9370DB':'MediumPurple'
'5':'#7B68EE':'MediumSlateBlue'
'6':'#6A5ACD':'SlateBlue'
'7':'#483D8B':'DarkSlateBlue'
'8':'#663399':'RebeccaPurple'
'9':'#4B0082':'Indigo'
// White Colors
'µ':'#FFFFFF':'White'
'¶':'#FFFAFA':'Snow'
'·':'#F0FFF0':'HoneyDew'
'¸':'#F5FFFA':'MintCream'
'¹':'#F0FFFF':'Azure'
'º':'#F0F8FF':'AliceBlue'
'»':'#F8F8FF':'GhostWhite'
'¼':'#F5F5F5':'WhiteSmoke'
'½':'#FFF5EE':'SeaShell'
'¾':'#F5F5DC':'Beige'
'¿':'#FDF5E6':'OldLace'
'À':'#FFFAF0':'FloralWhite'
'Á':'#FFFFF0':'Ivory'
'Â':'#FAEBD7':'AntiqueWhite'
'Ã':'#FAF0E6':'Linen'
'Ä':'#FFF0F5':'LavenderBlush'
'Å':'#FFE4E1':'MistyRose'
// Brown Colors
'£':'#FFF8DC':'Cornsilk'
'¤':'#FFEBCD':'BlanchedAlmond'
'¥':'#FFE4C4':'Bisque'
'¦':'#FFDEAD':'NavajoWhite'
'§':'#F5DEB3':'Wheat'
'¨':'#DEB887':'BurlyWood'
'©':'#D2B48C':'Tan'
'ª':'#BC8F8F':'RosyBrown'
'«':'#F4A460':'SandyBrown'
'¬':'#DAA520':'GoldenRod'
'­':'#B8860B':'DarkGoldenRod'
'®':'#CD853F':'Peru'
'¯':'#D2691E':'Chocolate'
'°':'#808000':'Olive'
'±':'#8B4513':'SaddleBrown'
'²':'#A0522D':'Sienna'
'³':'#A52A2A':'Brown'
'´':'#800000':'Maroon'
// Grey Colors
'Æ':'#DCDCDC':'Gainsboro'
'Ç':'#D3D3D3':'LightGray'
'È':'#C0C0C0':'Silver'
'É':'#A9A9A9':'DarkGray'
'Ê':'#696969':'DimGray'
'Ë':'#808080':'Gray'
'Ì':'#778899':'LightSlateGray'
'Í':'#708090':'SlateGray'
'Î':'#2F4F4F':'DarkSlateGray'
'Ñ':'#000000':'Black',

'Ø':'#00000000':'Transparent'
					</textarea>
					<br/>
					<h3>Sprite array</h3>
					<textarea id="spriteID" name="sprite" rows="35" cols="35" style="height: 35%;"">
[
"ØØØØØØØÑÑÑÑØÑÑÑØ",
"ØØØØØÑÑ@@@ÑÑNNNÑ",
"ØØØØÑ@@@@@@ÑNNNÑ",
"ØØØÑ@@@ÑÑÑÑÑÑNNÑ",
"ØØÑ@@@ÑÑÑÑÑÑÑÑNÑ",
"ØØÑ@ÑÑNNNNNNÑÑÑØ",
"ØÑÑÑÑNNNÑNÑNÑ@@Ñ",
"ØÑNÑÑNNNÑNÑNÑ@@Ñ",
"ÑNNÑÑÑNNNNNNNÑ@Ñ",
"ÑNNNÑNNÑNNNNNÑ@Ñ",
"ØÑNNNNÑÑÑÑNNÑÑÑØ",
"ØØÑÑNNNNÑÑÑÑÑ@ÑØ",
"ØØØÑÑÑNNNNNÑ@@ÑØ",
"ØØÑ@@@ÑÑÑÑÑÑ@ÑØØ",
"ØÑ@@@@@ÑÑ@@ÑÑØØØ",
"Ñ@@@ÑÑÑ@Ñ@@@ÑÑØØ",
"Ñ@@ÑNNNÑÑÑ@@@ÑØØ",
"Ñ@ÑNNNNNÑÑÑ@@ÑÑØ",
"ØÑÑNNNNNÑIIÑÑIÑØ",
"ØØÑÑNNNÑÑIIÑÑ±±Ñ",
"ØÑ±±ÑÑÑÑÑÑÑÑ±±±Ñ",
"Ñ±±ÑÑÑÑÑÑÑÑÑ±±±Ñ",
"Ñ±±ÑÑÑÑÑÑÑÑÑ±±±Ñ",
"Ñ±±ÑÑÑÑØØØØÑ±±ÑÑ",
"Ñ±±ÑÑØØØØØØØÑÑÑØ",
"ØÑÑØØØØØØØØØØØØØ"
]						
					</textarea>
				</td>
			</tr>
			<tr>
				<td>
					<button onclick="moveImageHorizontal(-100.0)">-100</button>
					<button onclick="moveImageHorizontal(-10.00)">-10.0</button>
					<button onclick="moveImageHorizontal(-1.000)">-1.00</button>
				</td>
				<td>Move Image</td>
				<td>
					<button onclick="moveImageHorizontal(100.0)">+100</button>
					<button onclick="moveImageHorizontal(10.00)">+10.0</button>
					<button onclick="moveImageHorizontal(1.000)">+1.00</button>
				</td>
			</tr>
			<tr>
				<td></td>
				<td>
					<button onclick="moveImageVertical(100.0)">+100</button>
					<button onclick="moveImageVertical(10.00)">+10.0</button>
					<button onclick="moveImageVertical(1.000)">+1.00</button>
				</td>
				<td></td>
			</tr>
			<tr>
				<td>
					<button onclick="zoomImage(-1.00)">-1.00</button>
					<button onclick="zoomImage(-0.10)">-0.10</button>
					<button onclick="zoomImage(-0.01)">-0.01</button>
				</td>
				<td>Image Zoom</td>
				<td>
					<button onclick="zoomImage(1.00)">+1.00</button>
					<button onclick="zoomImage(0.10)">+0.10</button>
					<button onclick="zoomImage(0.01)">+0.01</button>
				</td>
			</tr>
			<tr>
				<td>
					<button onclick="zoomGrid(-2.00)">-2.00</button>
					<button onclick="zoomGrid(-1.00)">-1.00</button>
					<button onclick="zoomGrid(-0.50)">-0.50</button>
					<button onclick="zoomGrid(-0.10)">-0.10</button>
				</td>
				<td>Grid Zoom</td>
				<td>
					<button onclick="zoomGrid(2.00)">+2.00</button>
					<button onclick="zoomGrid(1.00)">+1.00</button>
					<button onclick="zoomGrid(0.50)">+0.50</button>
					<button onclick="zoomGrid(0.10)">+0.10</button>
				</td>
			</tr>
			<tr>
				<td>
					<button onclick="spriteDelColumn()">Sub</button>
				</td>
				<td>Grid X Column</td>
				<td>
					<button onclick="spriteAddColumn()">Add</button>
				</td>
			</tr>
			<tr>
				<td>
					<button onclick="spriteDelRow()">Sub</button>
				</td>
				<td>Grid Y Row</td>
				<td>
					<button onclick="spriteAddRow()">Add</button>
				</td>
			</tr>
			<tr>
				<td id="selectedColorInfo" colspan="3"><b>Selected Color Info</b></td>
			</tr>
			<tr>
				<td colspan="3">
					<h3>Sprite</h3>
					<canvas id="spriteImage"></canvas>
				</td>
			</tr>
			<tr class="custom-height">
				<td colspan="3"></td>
			</tr>
		</tbody>
	</table>

	//<script type="module" src="./spritePallets.js"></script>
	<script type="module">
		//import { SpritePallets } from './spritePallets.js';

		// ---------------------------------
		// Get the canvas element
		var canvasEditor = document.getElementById("spriteEditor");

		// Set the canvas dimensions
		canvasEditor.width = 1600;
		canvasEditor.height = 1200;

		// Create a new CanvasRenderingContext2D object
		var ctxEditor = canvasEditor.getContext("2d");

		// SpriteImage
		var canvasImage = document.getElementById("spriteImage");

		const maxGrid = 32;
		let gridCellWidth = maxGrid;
		let gridCellHeight = maxGrid;
		let spriteIndex = new Array(gridCellWidth);
		let spriteColor = new Array(gridCellWidth);

		// Define the width and height of each sprite
		let spriteSize = 50
		const imageSize = 5;
		const spriteImageSize = maxGrid * imageSize + 4;

		// Set the canvas iamge dimensions
		canvasImage.width = spriteImageSize;
		canvasImage.height = spriteImageSize;

		// Create a new CanvasRenderingContext2D object
		var ctxImage = canvasImage.getContext("2d");

		let scaleFactor = 1.0; // Zoom factor

		// Define the pallet of colors
		const transparentColor = "#00000000";
		const palletAcrossCnt = 5;
		const palletDownCnt = 36;
		const palletSize = 30;

		let palletLetters = [];
		let palletColors = [];
		let palletNames = [];

		function loadPallet() {

// // Iterating over the spritePallets object top to bottom
// Object.entries(spritePallets).forEach(([symbol, { hex, name }]) => {
//     console.log(`Symbol: ${symbol}, Hex: ${hex}, Name: ${name}`);
// });

			const textarea = document.getElementById('palletID');
			const content = textarea.value;

			// Remove comments and extra whitespace, then split by commas
			const cleanContent = content
				.replace(/\/\/.*/g, '')  // Remove comments
				.replace(/\s+/g, '')     // Remove extra spaces
				.trim();

			// Initialize arrays and Set to track duplicates
			palletLetters = [];
			palletColors = [];
			const letterSet = new Set();  // Set to check for duplicates

			// Match the key-value pairs (e.g., 'R': 'Red')
			//const regex = /'([^']+)'\s*:\s*'([^']+)'/g;
			const regex = /'([^']+)'\s*:\s*'([^']+)'\s*:\s*'([^']+)'/g;

			let match;

			// Parse the content and populate the arrays
			while ((match = regex.exec(cleanContent)) !== null) {
				const letter = match[1];
				const color = match[2];
				const name = match[3];

				// Check for duplicate letters
				if (letterSet.has(letter)) {
					throw new Error(`Duplicate letter found: ${letter},  ${color},  ${name}`);
				}

				letterSet.add(letter);
				palletLetters.push(letter);
				palletColors.push(color);
				palletNames.push(name);
			}
		}

		function loadSprite() {
			const spriteTextarea = document.getElementById("spriteID");
			const spriteContent = spriteTextarea.value.trim();

			// Parse rows from the input, removing brackets and splitting by commas
			const rows = spriteContent.replace(/[\[\]]/g, "").split(",").map(row => row.trim().replace(/"/g, ""));

			// Set grid dimensions based on the parsed rows
			gridCellHeight = rows.length;
			gridCellWidth = rows[0]?.length || 0;

			// Log debugging information
			//console.log("Grid Dimensions:", gridCellWidth, gridCellHeight);

			// // Initialize spriteIndex and spriteColor arrays

			// Process each row and populate spriteIndex and spriteColor
			for (let y = 0; y < gridCellHeight; y++) {
				const row = rows[y];
				for (let x = 0; x < gridCellWidth; x++) {
					const letter = row[x];

					// Update spriteIndex
					spriteIndex[x][y] = letter;

					// Find the corresponding color
					const letterIndex = palletLetters.indexOf(letter);
					spriteColor[x][y] = letterIndex !== -1 ? palletColors[letterIndex] : transparentColor;

					// Log invalid colors
					if (letterIndex === -1) {
						console.log(`Invalid color at (${x}, ${y}): "${letter}"`);
						spriteColor[x][y] = 'red';
					}
				}
			}

			// Log results
			//console.log("Sprite Index:", spriteIndex);
			//console.log("Sprite Color:", spriteColor);
		}

		const gridX = palletSize * (palletAcrossCnt + 1) + palletSize / 4;
		const gridY = palletSize;

		let selectedColor = transparentColor;
		let selectedColorIndex = 0;
		let selectedCellX = 0;
		let selectedCellY = 0;

		let imageX = gridX;
		let imageY = gridY;
		const image = new Image();
		image.src = '8bit tiles.jpg';

		initArrays();

		function initArrays() {
			for (let x = 0; x < maxGrid; x++) {
				spriteIndex[x] = new Array(maxGrid).fill('0');
				spriteColor[x] = new Array(maxGrid).fill(transparentColor);
			}
		}


		function moveImageHorizontal(moveFactor) {
			imageX += moveFactor;
			drawAll();
		}
		function moveImageVertical(moveFactor) {
			imageY += moveFactor;
			drawAll();
		}

		function zoomImage(zoomFactor) {
			scaleFactor += zoomFactor;
			if (scaleFactor >= 5.0) {
				scaleFactor = 5.0;
			} else if (scaleFactor <= 0.3) {
				scaleFactor = 0.3;
			}
			drawAll();
			//console.log(scaleFactor);
		}

		function zoomGrid(zoomFactor) {
			spriteSize += zoomFactor;
			drawAll();
		}

		function spriteAddRow() {
			if (gridCellHeight < maxGrid) {
				gridCellHeight++;
				drawAll();
			} else {
				console.error("Cannot add row, gridCellHeight is already 32.");
			}
		}
		function spriteAddColumn() {
			if (gridCellWidth < maxGrid) {
				gridCellWidth++;
				drawAll();
			} else {
				console.error("Cannot add column, gridCellWidth is already 32.");
			}
		}
		function spriteDelColumn() {
			if (gridCellWidth > 0) {
				gridCellWidth--;
				drawAll();
			} else {
				console.error("Cannot remove column, gridCellWidth is already 0.");
			}
		}
		function spriteDelRow() {
			if (gridCellHeight > 0) {
				// spriteIndex.pop();
				// spriteColor.pop();
				gridCellHeight--;
				drawAll();
			} else {
				console.error("Cannot remove row, gridCellHeight is already 0.");
			}
		}

		function drawAll() {
			// Clear the canvas and set background color to #333333
			ctxEditor.clearRect(0, 0, canvasEditor.width, canvasEditor.height); // Clear the canvasEditor
			ctxEditor.fillStyle = '#333333'; // Set background color to dark gray
			ctxEditor.fillRect(0, 0, canvasEditor.width, canvasEditor.height); // Fill the entire canvasEditor

			ctxEditor.save();
			ctxEditor.scale(scaleFactor, scaleFactor);
			ctxEditor.drawImage(image, imageX, imageY);
			ctxEditor.restore();

			drawGrid();
			drawPallet();
			drawSelectedColor();
			drawSpriteImage();
			outputSprite();
		}

		function drawSpriteImage() {
			const fillColor = "#888888";
			const offset = 2;

			// Clear the canvas and set background color to #333333
			ctxImage.clearRect(0, 0, canvasImage.width, canvasImage.height); // Clear the canvasEditor
			ctxImage.fillStyle = fillColor; // Set background color to dark gray
			ctxImage.fillRect(0, 0, canvasImage.width, canvasImage.height); // Fill the entire canvasEditor

			// Sprite image
			for (var x = 0; x < gridCellWidth; x++) {
				for (var y = 0; y < gridCellHeight; y++) {
					const gridCellPosX = x * imageSize + offset;
					const gridCellPosY = y * imageSize + offset;

					ctxImage.fillStyle = spriteColor[x][y];
					ctxImage.fillRect(gridCellPosX, gridCellPosY, imageSize, imageSize); // (x, y, width, height)

				}
			}
		}

		function drawGrid() {
			ctxEditor.strokeStyle = "black";
			ctxEditor.fillStyle = "#black";

			ctxEditor.lineWidth = 2;

			// Lines on X
			for (var x = 0; x < gridCellWidth + 1; x++) {
				ctxEditor.beginPath();
				ctxEditor.moveTo(x * spriteSize + gridX, gridY);
				ctxEditor.lineTo(x * spriteSize + gridX, spriteSize * gridCellHeight + gridY);
				ctxEditor.stroke();
			}

			// Lines on Y
			for (var y = 0; y < gridCellHeight + 1; y++) {
				ctxEditor.beginPath();
				ctxEditor.moveTo(gridX, y * spriteSize + gridY);
				ctxEditor.lineTo(spriteSize * gridCellWidth + gridX, y * spriteSize + gridY);
				ctxEditor.stroke();
			}

			// Grid
			for (var x = 0; x < gridCellWidth; x++) {
				for (var y = 0; y < gridCellHeight; y++) {
					//					console.log("x:", x, "y:",y, "w:", gridCellWidth,"h:",gridCellHeight );
					if (spriteColor[x][y] === undefined) {
						spriteColor[x][y] = transparentColor;
					}
					if (spriteColor[x][y] === transparentColor) {
						const gridCellPosX = gridX + (spriteSize * x) + spriteSize / 4;
						const gridCellPosY = gridY + (spriteSize * y) + spriteSize / 4;
						drawTransparentX(gridCellPosX, gridCellPosY, spriteSize / 2);
					} else {
						drawColor(x, y, spriteColor[x][y]);
						if (false) {
							const gridCellPosX = gridX + (spriteSize * x) + spriteSize / 3;
							const gridCellPosY = gridY + (spriteSize * y) + (spriteSize / 3) + 15;

							// Set font properties
							ctxEditor.font = '20px Arial';
							ctxEditor.fillStyle = 'black';

							// Draw filled text
							ctxEditor.fillText(spriteIndex[x][y], gridCellPosX, gridCellPosY);

							// Optional: Outline the text
							ctxEditor.strokeStyle = 'white';
							ctxEditor.strokeText(spriteIndex[x][y], gridCellPosX, gridCellPosY);
						}
					}
				}
			}
		}
		function drawColor(x, y, color) {
			// Draw a circle on the selected sprite
			ctxEditor.beginPath();
			ctxEditor.arc((spriteSize * x) + gridX + spriteSize / 2,
				(spriteSize * y) + gridY + spriteSize / 2,
				spriteSize / 3, 0, 2 * Math.PI);
			ctxEditor.strokeStyle = color;
			ctxEditor.fillStyle = color;
			ctxEditor.stroke();
			ctxEditor.fill();
		}
		function drawTransparentX(x, y, size) {
			// Calculate circle parameters
			const centerX = x + size / 2; // Center X-coordinate
			const centerY = y + size / 2; // Center Y-coordinate
			const radius = size / 3;      // Radius of the circle

			// Draw the circle
			ctxEditor.beginPath();
			ctxEditor.arc(centerX, centerY, radius, 0, Math.PI * 2);
			ctxEditor.fillStyle = '#ffffff88'; // 50% white
			ctxEditor.fill();
			ctxEditor.strokeStyle = '#FF000088'; // 50% transparent red
			ctxEditor.lineWidth = 2;
			ctxEditor.stroke();

			// Draw the X
			ctxEditor.beginPath();
			ctxEditor.moveTo(centerX - radius, centerY - radius);
			ctxEditor.lineTo(centerX + radius, centerY + radius);
			ctxEditor.moveTo(centerX + radius, centerY - radius);
			ctxEditor.lineTo(centerX - radius, centerY + radius);
			ctxEditor.lineWidth = 2;
			ctxEditor.stroke();
		}

		let palletSelectedX = 0;
		let palletSelectedY = 0;
		let palletScale = (palletSize / spriteSize);

		const palletSpacing = 10;
		function drawSelectedColor() {
			ctxEditor.strokeStyle = "white";
			ctxEditor.lineWidth = 4;
			ctxEditor.strokeRect(
				palletSelectedX * palletSize + palletSpacing / 4,
				palletSelectedY * palletSize + palletSpacing / 4,
				palletSize, palletSize);

			const selectedColorInfo = document.getElementById("selectedColorInfo");
			selectedColorInfo.innerHTML = `<b>Selected Color Info</b><br>` +
				`Index:  ${selectedColorIndex} <br>` +
				`Char:   ${palletLetters[selectedColorIndex]} <br>` +
				`Code:   ${palletColors[selectedColorIndex]} <br>` +
				`Name:   ${palletNames[selectedColorIndex]} `;
		}
		function drawPallet() {
			palletScale = (palletSize / spriteSize);

			ctxEditor.clearRect(0, 0, spriteSize * palletAcrossCnt * palletScale + palletSpacing, canvasEditor.height); // Clear the canvasEditor
			ctxEditor.fillStyle = 'black';
			ctxEditor.fillRect(0, 0, spriteSize * palletAcrossCnt * palletScale + palletSpacing, canvasEditor.height); // Fill the entire canvasEditor
			for (var i = 0; i < palletColors.length; i++) {
				let div = i % palletAcrossCnt;
				let mod = Math.floor(i / palletAcrossCnt);
				const newX = div * palletSize + palletSpacing / 2;
				const newY = mod * palletSize + palletSpacing / 2;

				if (palletColors[i] === transparentColor) {
					drawTransparentX(newX, newY, spriteSize * palletScale);
				} else {
					ctxEditor.fillStyle = palletColors[i];
					ctxEditor.fillRect(newX, newY, spriteSize * palletScale - palletSpacing / 2, spriteSize * palletScale - palletSpacing / 2);
				}
			}
		}

		function getMousePositionOncanvas(canvas, event) {
			const rect = canvas.getBoundingClientRect(); // Get canvas bounding box
			const scaleX = canvas.width / rect.width;   // Scale factor for X
			const scaleY = canvas.height / rect.height; // Scale factor for Y

			const x = (event.clientX - rect.left) * scaleX; // Adjusted X coordinate
			const y = (event.clientY - rect.top) * scaleY;  // Adjusted Y coordinate

			return { x, y };
		}

		function outputSprite() {
			let c = "[\n";
			//console.log(spriteIndex);
			for (let x = 0; x < gridCellHeight; x++) {
				let r = "";
				for (let y = 0; y < gridCellWidth; y++) {
					const letterIndex = spriteIndex[y][x];
					//console.log(letterIndex, palletLetters[letterIndex], palletLetters);
					r += letterIndex;//palletLetters[letterIndex];
				}
				c += '"' + r + '",\n';
			}
			c += ']';
			//console.log(c);
			const spriteTextarea = document.getElementById("spriteID");
			spriteTextarea.value = c;
		}

		// Add an event listener to the canvas for clicks
		canvasEditor.addEventListener("click", function (event) {

			const mouse = getMousePositionOncanvas(canvasEditor, event);

			if (mouse.x > (spriteSize * palletAcrossCnt) * palletScale) {
				// Determine which sprite cell clicked
				selectedCellX = Math.floor((mouse.x - gridX) / spriteSize);
				selectedCellY = Math.floor((mouse.y - gridY) / spriteSize);

				if (selectedCellX < 0 || selectedCellX > gridCellWidth - 1 ||
					selectedCellY < 0 || selectedCellY > gridCellHeight - 1) {
					return;
				}
				// Set the array elements
				spriteIndex[selectedCellX][selectedCellY] = palletLetters[selectedColorIndex];
				spriteColor[selectedCellX][selectedCellY] = palletColors[selectedColorIndex];
			} else {
				// Determine which pallet color was clicked
				var clickedPalletX = Math.floor(mouse.x / palletSize);
				var clickedPalletY = Math.floor(mouse.y / palletSize);
				var clickedPallet = clickedPalletX + clickedPalletY * palletAcrossCnt;

				if (clickedPallet > palletColors.length - 1) {
					return; // don't allow invalid color index
				}

				selectedColorIndex = clickedPallet;

				palletSelectedX = clickedPalletX;
				palletSelectedY = clickedPalletY;
			}
			drawAll();
		});

		window.onload = function () {
			loadPallet();
			loadSprite();
			drawAll();
		};
	</script>

</body>

</html>